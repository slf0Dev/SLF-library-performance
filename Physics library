
-- Instances:

local fake_module_scripts = {}

do 
	local script = Instance.new('ModuleScript', game.ReplicatedStorage)
	script.Name = "Nature2D"
	local function module_script()
		return require(script.Engine)
	end
	fake_module_scripts[script] = module_script
end

local Constants = Instance.new("Folder")
local Debugging = Instance.new("Folder")
local Physics = Instance.new("Folder")
local Utilities = Instance.new("Folder")

--Properties:

Constants.Name = "Constants"
Constants.Parent = game.ReplicatedStorage["Nature2D"]

Debugging.Name = "Debugging"
Debugging.Parent = game.ReplicatedStorage["Nature2D"]

Physics.Name = "Physics"
Physics.Parent = game.ReplicatedStorage["Nature2D"]

Utilities.Name = "Utilities"
Utilities.Parent = game.ReplicatedStorage["Nature2D"]

-- Module Scripts:




-- Module Scripts:

local fake_module_scripts = {}

do -- nil.Plugins
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D)
	script.Name = "Plugins"
	local function module_script()
		return {
			MouseConstraint = require(script.MouseConstraint),
			Quad = require(script.Quad),
			Triangle = require(script.Triangle)
		}
	end
	fake_module_scripts[script] = module_script
end
do -- nil.MouseConstraint
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Plugins)
	script.Name = "MouseConstraint"
	local function module_script()
		local UserInputService = game:GetService("UserInputService")

		return function (engine: { any }, range: number)
			local mousePoint = engine:Create("Point", {
				Position = UserInputService:GetMouseLocation(),
				Visible = false,
				Snap = true,
				KeepInCanvas = false
			})
			local held = nil
			local constraint = nil

			UserInputService.InputBegan:Connect(function(input, processedEvent)
				if processedEvent then return end

				if input.UserInputType == Enum.UserInputType.MouseButton1 and not held and not constraint then 
					for _, b in ipairs(engine.bodies) do 
						for _, p in ipairs(b.vertices) do 
							if (p.pos - UserInputService:GetMouseLocation()).Magnitude <= range then 
								p.selectable = true
								held = p
								constraint = engine:Create("Constraint", {
									Type = "Rod",
									Point1 = held,
									Point2 = mousePoint,
									RestLength = 1,
									Visible = false
								})			
								break
							end
						end

						if held then
							break
						end
					end
				end
			end)

			UserInputService.InputEnded:Connect(function(input, processedEvent)
				if processedEvent then return end

				if input.UserInputType == Enum.UserInputType.MouseButton1 and held and constraint then 
					held.selectable = false
					constraint:Destroy()
					held = nil
					constraint = nil
				end
			end)

			UserInputService.InputChanged:Connect(function(input, processedEvent)
				if processedEvent then return end

				if input.UserInputType == Enum.UserInputType.MouseMovement then
					local mouse = UserInputService:GetMouseLocation()
					mousePoint:SetPosition(mouse.X, mouse.Y)
				end
			end)
		end
	end
	fake_module_scripts[script] = module_script
end
do -- nil.Quad
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Plugins)
	script.Name = "Quad"
	local function module_script()
		-- Returns a quadrilateral structure for Custom RigidBodies given 4 points
		return function (a: Vector2, b: Vector2, c: Vector2, d: Vector2)
			return {
				{ a, b, false }, 
				{ b, c, false }, 
				{ c, d, false }, 
				{ d, a, false }, 
				{ a, c, true }, 
				{ b, d, true }
			}
		end
	end
	fake_module_scripts[script] = module_script
end
do -- nil.Triangle
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Plugins)
	script.Name = "Triangle"
	local function module_script()
		-- Returns a triangular structure for Custom RigidBodies given 3 points
		return function (a: Vector2, b: Vector2, c: Vector2)
			return {
				{ a, b, false }, 
				{ a, c, false }, 
				{ b, c, false }
			}
		end
	end
	fake_module_scripts[script] = module_script
end



-- Module Scripts:

local fake_module_scripts = {}

do -- nil.Types
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D)
	script.Name = "Types"
	local function module_script()
		-- Type Definitions

		export type Quadtree<T> = {
			position: Vector2,
			size: Vector2,
			capacity: number,
			objects: {T},
			divided: boolean,
		}

		export type Canvas = {
			topLeft: Vector2,
			size: Vector2,
			frame: Frame?
		}

		export type Point = {
			Parent: any,
			frame: Frame?,
			engine: { any },
			canvas: Canvas,
			oldPos: Vector2,
			pos: Vector2,
			forces: Vector2,
			gravity: Vector2,
			friction: number,
			airfriction: number,
			bounce: number,
			snap: boolean,
			selectable: boolean,
			render: boolean,
			keepInCanvas: boolean,
			color: Color3?,
			radius: number
		}

		export type RigidBody = {
			CreateProjection: (Axis: Vector2, Min: number, Max: number) -> (number, number),
			SetState: (state: string, value: any) -> (),
			GetState: (state: string) -> any,
			id: string,
			vertices: { Point },
			edges: { any },
			frame: GuiObject?,
			anchored: boolean,
			mass: number,
			collidable: boolean,
			center: Vector2,
			engine: { any },
			spawnedAt: number,
			lifeSpan: number?,
			anchorRotation: number?,
			anchorPos: Vector2?,
			Touched: any,
			CanvasEdgeTouched: any,
			States: { any }
		}

		export type SegmentConfig = {
			restLength: number?, 
			render: boolean, 
			thickness: number?,
			support: boolean,
			TYPE: string,
		}

		export type EngineConfig = {
			gravity: Vector2,
			friction: number,
			bounce: number,
			speed: number,
			airfriction: number,
		}

		export type PointConfig = {
			snap: boolean, 
			selectable: boolean, 
			render: boolean,
			keepInCanvas: boolean
		}

		export type Collision = {
			axis: Vector2,
			depth: number,
			edge: any,
			vertex: Point
		}

		export type Range = {
			position: Vector2,
			size: Vector2
		}

		export type Properties = {
			Position: Vector2?,
			Visible: boolean?,
			Snap: boolean?,
			KeepInCanvas: boolean?,
			Radius: number?,
			Color: Color3?,
			Type: string?,
			Point1: Point?,
			Point2: Point?,
			Thickness: number?, 
			RestLength: number?,
			SpringConstant: number?,
			Object: GuiObject?, 
			Collidable: boolean?, 
			Anchored: boolean?,
			LifeSpan: number?,
			Gravity: Vector2?,
			Friction: number?,
			AirFriction: number?,
			Structure: {}?,
			Mass: number?,
			CanRotate: boolean
		}

		export type Custom = {
			Vertices: { any },
			Edges: { any }
		}

		export type Plugins = {
			Triangle: (a: Vector2, b: Vector2, c: Vector2) -> (),
			Quad: (a: Vector2, b: Vector2, c: Vector2, d: Vector2) -> (),
			MouseConstraint: (engine: { any }, range: number, rigidbodies: { any }) -> ()
		}

		export type DebugInfo = {
			Objects: { 
				RigidBodies: number,
				Constraints: number,
				Points: number
			},
			Running: boolean,
			Physics: {
				Gravity: Vector2,
				Friction: number,
				AirFriction: number,
				CollisionMultiplier: number,
				TimeSteps: number,
				SimulationSpeed: number,
				UsingQuadtrees: boolean,
				FramerateIndependent: boolean
			},
			Path: ScreenGui,
			Canvas: {
				Frame: GuiObject,
				TopLeft: Vector2,
				Size: Vector2
			}
		}

		return nil
	end
	fake_module_scripts[script] = module_script
end

-- Gui to Lua
-- Version: 3.2

-- Instances:



--Properties:



-- Module Scripts:

local fake_module_scripts = {}

do -- nil.Globals
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Constants)
	script.Name = "Globals"
	local function module_script()

		return {
			engineInit = {
				gravity = Vector2.new(0, .3),
				friction = 0.9,
				airfriction = 0.98,
				bounce = 0.8,
				timeSteps = 1,
				canvas = {
					topLeft = Vector2.new(0, 0),
					size = workspace.CurrentCamera.ViewportSize,
				},
			},
			universalMass = 1,
			speed = 55,
			properties = {
				"gravity",
				"friction",
				"collisionmultiplier",
				"airfriction",
				"universalmass"
			},
			rigidbody = {
				props = {
					"Object",
					"Collidable",
					"Anchored",
					"LifeSpan",
					"KeepInCanvas",
					"Gravity",
					"Friction",
					"AirFriction",
					"Structure",
					"Mass",
					"CanRotate"
				},
				must_have = {
					"Object"
				}
			},
			constraint = {
				color = Color3.new(1, 1, 1),
				thickness = 4,
				types = {
					"rope",
					"spring",
					"rod"
				},
				props = {
					"Type",
					"Point1",
					"Point2",
					"Visible",
					"Thickness",
					"RestLength",
					"SpringConstant",
					"Color",
				},
				must_have = {
					"Type",
					"Point1",
					"Point2",
				}
			},
			point = {
				radius = 2.5,
				color = Color3.new(1),
				uicRadius = UDim.new(1, 0),
				props = {
					"Position",
					"Visible",
					"Snap",
					"KeepInCanvas",
					"Radius",
					"Color"
				},
				must_have = {
					"Position"
				}
			},
			offset = Vector2.new(0, 36),

			VALID_OBJECT_PROPS = {
				"Position",
				"Visible",
				"Snap",
				"KeepInCanvas",
				"Radius",
				"Color",
				"Type",
				"Point1",
				"Point2",
				"Thickness",
				"RestLength",
				"SpringConstant",
				"Object",
				"Collidable",
				"Anchored",
				"LifeSpan",
				"Gravity",
				"Friction",
				"AirFriction",
				"Structure",
				"Mass",
				"CanRotate"
			},

			OBJECT_PROPS_TYPES = {
				Position = "Vector2",
				Visible = "boolean",
				Snap = "boolean",
				KeepInCanvas = "boolean",
				Radius = "number",
				Color = "Color3",
				Type = "string",
				Thickness = "number",
				RestLength = "number",
				SpringConstant = "number",
				Object = "Instance",
				Collidable = "boolean",
				Anchored = "boolean",
				LifeSpan = "number",
				Gravity = "Vector2",
				Friction = "number",
				AirFriction = "number",
				Structure = "table",
				Mass = "number",
				CanRotate = "boolean"
			},
		}

	end
	fake_module_scripts[script] = module_script
end
-- Gui to Lua
-- Version: 3.2

-- Instances:



--Properties:



-- Module Scripts:

local fake_module_scripts = {}

do -- nil.Exceptions
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Debugging)
	script.Name = "Exceptions"
	local function module_script()
		-- Handling exceptions

		local TYPES = {
			NO_CANVAS_FOUND = "No canvas found, initialize the engine's canvas using Engine:CreateCanvas().",
			NO_RIGIDBODIES_FOUND = "No rigid bodies found on start.",
			PROPERTY_NOT_FOUND = "Invalid Argument #1. Property not found.",
			INVALID_CONSTRAINT_TYPE = "Received Invalid Constraint Type.",
			INVALID_CONSTRAINT_LENGTH = "Received Invalid Constraint Length.",
			INVALID_CONSTRAINT_THICKNESS = "Received Invalid Constraint Thickness.",
			SAME_ID = "Cannot ignore collisions for the same RigidBodies.",
			INVALID_RIGIDBODY = "Received Invalid RigidBody.",
			INVALID_OBJECT = "Received an Invalid Object. Valid objects - RigidBody, Point and Constraint.",
			INVALID_PROPERTY = "Received an Invalid Object Property.",
			MUST_HAVE_PROPERTY = "Missing must-have properties.",
			CANVAS_FRAME_NOT_FOUND = "No canvas frame found, initialize the canvas's frame to render custom Points and Constraints!",
			INVALID_TIME = "Received invalid time to apply force for.",
			ALREADY_STARTED = "Engine is already running.",
			CANNOT_SET_COLLISION_ITERATIONS = "Cannot set collision iterations! You must turn on quadtree usage using Engine:UseQuadtrees(true)."
		}

		return function (TASK: string, TYPE: string, details: string?)
			if TYPES[TYPE] then 
				local exception = string.format("[Nature2D]: %s%s", TYPES[TYPE], if details then " "..details else "")

				if TASK == "warn" then 
					warn(exception)
				elseif TASK == "error" then 
					error(exception, 2)
				end
			end
		end

	end
	fake_module_scripts[script] = module_script
end
do -- nil.Restrict
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Debugging)
	script.Name = "Restrict"
	local function module_script()
		return function (custom)
			if custom then 
				error("[Nature2D]: This method cannot be used with custom RigidBodies", 2)
			end
		end
	end
	fake_module_scripts[script] = module_script
end
do -- nil.TypeErrors
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Debugging)
	script.Name = "TypeErrors"
	local function module_script()
		-- Handling type errors

		return function (arg: string, param, pos: number, expected: string)
			if typeof(param) ~= expected then
				error(
					string.format(
						"[Nature2D]: Invalid Argument #%s. Expected type %q for %s, got %q",
						tostring(pos),
						expected,
						arg,
						typeof(param)
					),	
					2
				)
			end
		end
	end
	fake_module_scripts[script] = module_script
end
-- Gui to Lua
-- Version: 3.2

-- Instances:



--Properties:



-- Module Scripts:

local fake_module_scripts = {}

do -- nil.Constraint
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Physics)
	script.Name = "Constraint"
	local function module_script()
		-- Constraints keep two points together in place and maintain uniform distance between the two.
		-- Constraints and Points together join to keep a RigidBody in place hence making both Points and Constraints a vital part of the library.
		-- Custom constraints such as Ropes, Rods, Bridges and chains can also be made.
		-- Points of two rigid bodies can be connected with constraints, two individual points can also be connected with constraints to form Ropes etc.

		-- Services and utilities
		local line = require(script.Parent.Parent.Utilities.Line)
		local Globals = require(script.Parent.Parent.Constants.Globals)
		local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
		local throwException = require(script.Parent.Parent.Debugging.Exceptions)
		local Janitor = require(script.Parent.Parent.Utilities.Janitor)
		local Types = require(script.Parent.Parent.Types)
		local https = game:GetService("HttpService")

		local Constraint = {}
		Constraint.__index = Constraint

		-- This method is used to initialize a constraint.
		function Constraint.new(p1: Types.Point, p2: Types.Point, canvas: Types.Canvas, config: Types.SegmentConfig, engine, parent)
			local self = setmetatable({
				id = https:GenerateGUID(false),
				_janitor = nil,
				engine = engine,
				Parent = parent,
				frame = nil,
				canvas = canvas,
				point1 = p1,
				point2 = p2,
				restLength = config.restLength or (p2.pos - p1.pos).Magnitude,
				render = config.render,
				thickness = config.thickness or Globals.constraint.thickness,
				support = config.support,
				_TYPE = config.TYPE,
				k = 0.1,
				color = nil,
			}, Constraint)

			local janitor = Janitor.new()
			janitor:Add(self, "Destroy")
			janitor:Add(self.point1, "Destroy")
			janitor:Add(self.point2, "Destroy")
			if self.Parent then
				janitor:Add(self.Parent, "Destroy")
			end
			self._janitor = janitor

			self.point1.Parent = self
			self.point2.Parent = self
			self.point1._janitor:Add(self.point1.Parent, "Destroy")
			self.point2._janitor:Add(self.point2.Parent, "Destroy")

			return self
		end

		-- This method is used to keep uniform distance between the constraint's points, i.e. constrain.
		function Constraint:Constrain()
			local cur = (self.point2.pos - self.point1.pos).Magnitude
			local force

			-- Validate constraint types
			if self._TYPE == "ROPE" then
				local restLength = self.restLength
				if cur < self.thickness then
					restLength = self.thickness
				end

				if cur > self.restLength or self.restLength < self.thickness then
					-- Solve rope constraint force
					local offset = ((restLength - cur)/restLength)/2
					force = self.point2.pos - self.point1.pos
					force *= offset
				end
			elseif self._TYPE == "ROD" then
				-- Solve rod constraint force
				local offset = self.restLength - cur
				local dif = self.point2.pos - self.point1.pos
				dif = dif.Unit
				force = (dif * offset)/2
			elseif self._TYPE == "SPRING" then
				-- Solve spring constraint force
				force = self.point2.pos - self.point1.pos
				local mag = force.Magnitude - self.restLength
				force = force.Unit
				force *= -1 * self.k * mag
			else
				return
			end

			-- Apply forces to constraint's points
			if force then
				if not self.point1.snap then self.point1.pos -= force end
				if not self.point2.snap then self.point2.pos += force end
			end
		end

		-- This method is used to update the position and appearance of the constraint on screen.
		function Constraint:Render()
			if self.render and not self.support then
				if not self.canvas.frame then
					throwException("error", "CANVAS_FRAME_NOT_FOUND")
				end

				local thickness = self.thickness or Globals.constraint.thickness
				local color = self.color or Globals.constraint.color
				local image = self._TYPE == "SPRING" and "rbxassetid://8404350124" or nil

				if not self.frame then
					self.frame = line(self.point1.pos, self.point2.pos, self.canvas.frame, thickness, color, nil, image)
					self._janitor:Add(self.frame, "Destroy")
				end

				-- Draw constraint on screen
				line(self.point1.pos, self.point2.pos, self.canvas.frame, thickness, color, self.frame, image)
			end
		end

		-- Used to set the minimum constrained distance between two points.
		-- By default, the initial distance between the two points.
		function Constraint:SetLength(newLength: number)
			throwTypeError("length", newLength, 1, "number")
			if newLength <= 0 then
				throwException("error", "INVALID_CONSTRAINT_LENGTH")
			end

			self.restLength = newLength
		end

		-- This method returns the current distance between the two points of a constraint.
		function Constraint:GetLength() : number
			return (self.point2.pos - self.point1.pos).Magnitude
		end

		-- This method is used to change the color of a constraint.
		-- By default a constraint's color is set to the default value of (WHITE) Color3.new(1, 1, 1).
		function Constraint:Stroke(color: Color3)
			throwTypeError("color", color, 1, "Color3")
			self.color = color
		end

		-- This method destroys the constraint.
		-- Its UI element is no longer rendered on screen and the constraint is removed from the engine.
		-- This is irreversible.
		function Constraint:Destroy()
			self._janitor:Cleanup()

			if not self.Parent then
				for i, c in ipairs(self.engine.constraints) do
					if c.id == self.id then
						table.remove(self.engine.constraints, i)
						self.engine.ObjectRemoved:Fire(self)
						break
					end
				end
			end

			self.point1 = nil
			self.point2 = nil
		end

		-- Returns the constraints points.
		function Constraint:GetPoints()
			return self.point1, self.point2
		end

		-- Returns the UI element for the constrained IF rendered.
		function Constraint:GetFrame() : Frame?
			return self.frame
		end

		-- This method is used to update the Spring constant (by default 0.1) used for spring constraint calculations.
		function Constraint:SetSpringConstant(k: number)
			throwTypeError("springConstant", k, 1, "number")
			self.k = k
		end

		-- The constraints's unique ID can be fetched using this method.
		function Constraint:GetId() : string
			return self.id
		end

		-- Returns the Parent (RigidBody) of the Constraint if any.
		function Constraint:GetParent()
			return self.Parent
		end

		return Constraint
	end
	fake_module_scripts[script] = module_script
end
do -- nil.Point
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Physics)
	script.Name = "Point"
	local function module_script()
		-- Points are what make the rigid bodies behave like real world entities.
		-- Points are responsible for the movement of the RigidBodies and Constraints.

		-- Services and utilities
		local Globals = require(script.Parent.Parent.Constants.Globals)
		local Types = require(script.Parent.Parent.Types)
		local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
		local throwException = require(script.Parent.Parent.Debugging.Exceptions)
		local Janitor = require(script.Parent.Parent.Utilities.Janitor)
		local HttpService = game:GetService("HttpService")

		local Point = {}
		Point.__index = Point

		-- This method is used to initialize a new Point.
		function Point.new(pos: Vector2, canvas: Types.Canvas, engine: Types.EngineConfig, config: Types.PointConfig, parent)
			local self = setmetatable({
				id = HttpService:GenerateGUID(false),
				Parent = parent,
				frame = nil,
				_janitor = nil,
				engine = engine,
				canvas = canvas,
				oldPos = pos,
				pos = pos,
				forces = Vector2.new(),
				maxForce = nil,
				gravity = engine.gravity,
				friction = engine.friction,
				airfriction = engine.airfriction,
				bounce = engine.bounce,
				snap = config.snap,
				selectable = config.selectable,
				render = config.render,
				keepInCanvas = config.keepInCanvas,
				color = nil,
				radius = Globals.point.radius,
				timed = {
					start = nil,
					t = nil,
					force = Vector2.new()
				}
			}, Point)

			local janitor = Janitor.new()
			janitor:Add(self, "Destroy")
			if self.Parent then
				janitor:Add(self.Parent, "Destroy")
			end
			self._janitor = janitor

			return self
		end

		-- This method is used to apply a force to the Point.
		function Point:ApplyForce(force: Vector2, t: number)
			throwTypeError("force", force, 1, "Vector2")
			self.forces += force

			if t then
				throwTypeError("time", t, 2, "number")
				if t <= 0 then
					throwException("error", "INVALID_TIME")
				end

				self.timed.start = os.clock()
				self.timed.t = t
				self.timed.force = force
			end
		end

		-- This method is used to apply external forces like gravity and is responsible for moving the point.
		function Point:Update(dt: number)
			if not self.snap then
				self:ApplyForce(self.gravity)

				if self.timed.start then
					if os.clock() - self.timed.start < self.timed.t then
						self:ApplyForce(self.timed.force)
					else
						self.timed.start = nil
						self.timed.t = nil
						self.timed.force = Vector2.new()
					end
				end

				-- Calculate velocity
				local velocity = self.pos
				velocity -= self.oldPos
				if self.engine.independent then
					self.forces *= dt * self.engine.speed
				end
				velocity += self.forces

				local body = self.Parent

				-- Apply friction
				if body and body.Parent then
					local mass = body.Parent.mass

					if mass then
						self.forces /= mass
					end

					if body.Parent.Collisions.CanvasEdge or body.Parent.Collisions.Body then
						velocity *= self.friction
					else
						velocity *= self.airfriction
					end
				else
					velocity *= self.friction
				end

				-- clamp velocity
				if self.maxForce then
					velocity = Vector2.new(
						math.clamp(velocity.X, -self.maxForce, self.maxForce),
						math.clamp(velocity.Y, -self.maxForce, self.maxForce)
					)
				end

				-- Update point positions
				self.oldPos = self.pos
				self.pos += velocity
				self.forces *= 0
			end
		end

		-- This method is used to keep the point in the engine's canvas.
		-- Any point that goes past the canvas, is positioned correctly and the direction of its flipped is reversed accordingly.
		function Point:KeepInCanvas()
			-- vx = velocity.X
			-- vy = velocity.Y
			local vx = self.pos.X - self.oldPos.X
			local vy = self.pos.Y - self.oldPos.Y

			local boundX = self.canvas.topLeft.X + self.canvas.size.X
			local boundY = self.canvas.topLeft.Y + self.canvas.size.Y

			local collision = false
			local edge

			if self.pos.Y > boundY then
				self.pos = Vector2.new(self.pos.X, boundY)
				self.oldPos = Vector2.new(self.oldPos.X, self.pos.Y + vy * self.bounce)
				collision = true
				edge = "Bottom"
			elseif self.pos.Y < self.canvas.topLeft.Y then
				self.pos = Vector2.new(self.pos.X, self.canvas.topLeft.Y)
				self.oldPos = Vector2.new(self.oldPos.X, self.pos.Y - vy * self.bounce)
				collision = true
				edge = "Top"
			end

			if self.pos.X < self.canvas.topLeft.X then
				self.pos = Vector2.new(self.canvas.topLeft.X, self.pos.Y)
				self.oldPos = Vector2.new(self.pos.X + vx * self.bounce, self.oldPos.Y)
				collision = true
				edge = "Left"
			elseif self.pos.X > boundX then
				self.pos = Vector2.new(boundX, self.pos.Y)
				self.oldPos = Vector2.new(self.pos.X - vx * self.bounce, self.oldPos.Y)
				collision = true
				edge = "Right"
			end

			local body = self.Parent

			-- Fire CanvasEdgeTouched event
			if body and body.Parent then
				if collision then
					local prev = body.Parent.Collisions.CanvasEdge
					body.Parent.Collisions.CanvasEdge = true
					if prev == false then
						body.Parent.CanvasEdgeTouched:Fire(edge)
					end
				else
					body.Parent.Collisions.CanvasEdge = false
				end
			end
		end

		-- This method is used to update the position and appearance of the Point on screen.
		function Point:Render()
			if self.render then
				if not self.canvas.frame then
					throwException("error", "CANVAS_FRAME_NOT_FOUND")
				end

				if not self.frame then
					-- Create new instance for the point
					local p = Instance.new("Frame")
					local border = Instance.new("UICorner")
					local r = self.radius or Globals.point.radius

					p.AnchorPoint = Vector2.new(.5, .5)
					p.BackgroundColor3 = self.color or Globals.point.color
					p.Size = UDim2.new(0, r * 2, 0, r * 2)
					p.Parent = self.canvas.frame

					border.CornerRadius = Globals.point.uicRadius
					border.Parent = p

					self.frame = p

					self._janitor:Add(self.frame, "Destroy")
				end

				-- Update the point's instance
				self.frame.Position = UDim2.new(0, self.pos.x, 0, self.pos.y)
			end

			if self.keepInCanvas then
				self:KeepInCanvas()
			end
		end

		function Point:Destroy()
			self._janitor:Cleanup()

			if not self.Parent then
				for i, c in ipairs(self.engine.points) do
					if c.id == self.id then
						table.remove(self.engine.points, i)
						self.engine.ObjectRemoved:Fire(self)
						break
					end
				end
			end
		end

		-- This method is used to determine the radius of the point.
		function Point:SetRadius(radius: number)
			throwTypeError("radius", radius, 1, "number")
			self.radius = radius
		end

		-- his method is used to determine the color of the point on screen.
		-- By default this is set to (RED) Color3.new(1, 0, 0).
		function Point:Stroke(color: Color3)
			throwTypeError("color", color, 1, "Color3")
			self.color = color
		end

		-- This method determines if the point remains anchored.
		-- If set to false, the point is unanchored.
		function Point:Snap(snap: boolean)
			throwTypeError("snap", snap, 1, "boolean")
			self.snap = snap
		end

		-- Returns the velocity of the Point
		function Point:Velocity() : Vector2
			return self.pos - self.oldPos
		end

		-- Returns the Parent (Constraint) of the Point if any.
		function Point:GetParent()
			return self.Parent
		end

		-- Used to set a new position for the point
		function Point:SetPosition(x: number, y: number)
			throwTypeError("x", x, 1, "number")
			throwTypeError("y", y, 2, "number")
			local newPosition = Vector2.new(x, y)
			self.oldPos = newPosition
			self.pos = newPosition
		end

		-- Determines the max force that can be aoplied to the Point.
		function Point:SetMaxForce(maxForce: number)
			throwTypeError("maxForce", maxForce, 1, "number")
			self.maxForce = math.abs(maxForce)
		end

		return Point
	end
	fake_module_scripts[script] = module_script
end
do -- nil.RigidBody
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D.Physics)
	script.Name = "RigidBody"
	local function module_script()
		-- RigidBodies are formed by Constraints, Points and UI Elements.

		-- Services and utilities
		local Point = require(script.Parent.Point)
		local Constraint = require(script.Parent.Constraint)
		local Globals = require(script.Parent.Parent.Constants.Globals)
		local Signal = require(script.Parent.Parent.Utilities.Signal)
		local Types = require(script.Parent.Parent.Types)
		local Janitor = require(script.Parent.Parent.Utilities.Janitor)
		local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
		local throwException = require(script.Parent.Parent.Debugging.Exceptions)
		local restrict = require(script.Parent.Parent.Debugging.Restrict)
		local HttpService = game:GetService("HttpService")

		local RigidBody = {}
		RigidBody.__index = RigidBody

		-- [PRIVATE]
		-- This method is used to fetch the positions of the 4 corners of  UI element.
		local function GetCorners(frame: GuiObject, engine)
			local pos, size = frame.AbsolutePosition, frame.AbsoluteSize
			local rotation = math.rad(frame.Rotation)
			local center = pos + size/2
			local temp = math.sqrt((size.X/2)^2+(size.Y/2)^2)

			local offset = (engine.path and engine.path.IgnoreGuiInset) and Globals.offset or Vector2.new(0, 0)

			-- Calculate and return all 4 corners of the GuiObject
			-- Also adheres to the Rotation of the GuiObject
			local t = math.atan2(size.Y, size.X)
			local a = rotation + t
			local b = rotation - t

			return {
				center - temp * Vector2.new(math.cos(a), math.sin(a)) + offset, -- topleft
				center + temp * Vector2.new(math.cos(b), math.sin(b)) + offset, -- topright
				center - temp * Vector2.new(math.cos(b), math.sin(b)) + offset, -- bottomleft
				center + temp * Vector2.new(math.cos(a), math.sin(a)) + offset, -- bottomright
			}
		end

		-- This method is used to calculate the depth/penetration of a collision
		local function CalculatePenetration(minA: number, maxA: number, minB: number, maxB: number) : number
			if minA < minB then
				return minB - maxA
			else
				return minA - maxB
			end
		end

		local function CalculateOffset(pos, anchorPoint, size)
			return (Vector2.new(.5, .5) - anchorPoint) * size
		end

		-- This method is used to calculate the center position of a UI element
		local function CalculateCenter(vertices) : Vector2
			local center = Vector2.new(0, 0)

			local minX = math.huge
			local minY = math.huge
			local maxX = -math.huge
			local maxY = -math.huge

			for _, v in ipairs(vertices) do
				center += v.pos
				minX = math.min(minX, v.pos.x)
				minY = math.min(minY, v.pos.y)
				maxX = math.max(maxX, v.pos.x)
				maxY = math.max(maxY, v.pos.y)
			end

			center /= #vertices

			return center
		end

		-- Used to calculate the AbsoluteSize for custom RigidBodies
		local function CalculateSize(vertices)
			local minX = math.huge
			local minY = math.huge
			local maxX = -math.huge
			local maxY = -math.huge

			for _, v in ipairs(vertices) do
				minX = math.min(minX, v.pos.x)
				minY = math.min(minY, v.pos.y)
				maxX = math.max(maxX, v.pos.x)
				maxY = math.max(maxY, v.pos.y)
			end

			return Vector2.new(maxX - minX, maxY - minY)
		end

		local function CreateRotationCache(cache, center, vertices)
			table.clear(cache)

			for _, p in ipairs(vertices) do
				local r = (p.pos - center).Magnitude
				local theta = math.atan2(p.pos.Y - center.Y, p.pos.X - center.X)
				table.insert(cache, { r, theta })
			end
		end

		-- This method is used to update the positions of each point of a rigidbody to the corners of a UI element.
		local function UpdateVertices(frame: GuiObject, vertices, engine)
			local corners = GetCorners(frame, engine)
			for i, vertex in ipairs(vertices) do
				vertex:SetPosition(corners[i].X, corners[i].Y)
			end
		end

		-- [PUBLIC]
		-- This method is used to initialize a new RigidBody.
		function RigidBody.new(frame: GuiObject?, m: number, collidable: boolean?, anchored: boolean?, engine, custom: Types.Custom?, structure)
			local isCustom = false

			if custom then
				isCustom = true
			end

			local vertices = isCustom and custom.Vertices or {}
			local edges = isCustom and custom.Edges or {}

			-- Configurations
			local pointConfig = {
				snap = anchored,
				selectable = false,
				render = false,
				keepInCanvas = true
			}

			local constraintConfig = {
				restLength = nil,
				render = false,
				thickness = 4,
				support = false,
				TYPE = "ROD"
			}

			-- Point creation method
			local function addPoint(pos)
				local newPoint = Point.new(pos, engine.canvas, engine, pointConfig)
				vertices[#vertices + 1] = newPoint

				return newPoint
			end

			-- Constraint creation method
			local function addConstraint(p1, p2, support)
				constraintConfig.support = support

				local newConstraint = Constraint.new(p1, p2, engine.canvas, constraintConfig)
				edges[#edges + 1] = newConstraint

				return newConstraint
			end

			if not isCustom then
				-- Create Points
				local corners = GetCorners(frame, engine)
				local topleft = addPoint(corners[1])
				local topright = addPoint(corners[2])
				local bottomleft = addPoint(corners[3])
				local bottomright = addPoint(corners[4])

				-- Connect points with constraints
				addConstraint(topleft, topright, false)
				addConstraint(topleft, bottomleft, false)
				addConstraint(topright, bottomright, false)
				addConstraint(bottomleft, bottomright, false)
				addConstraint(topleft, bottomright, true)
				addConstraint(topright, bottomleft, true)
			end

			local self = setmetatable({
				id = HttpService:GenerateGUID(false),
				custom = isCustom,
				_janitor = Janitor.new(),		structure = structure,
				vertices = vertices,
				edges = edges,
				frame = isCustom or nil or frame,
				size = isCustom and CalculateSize(vertices) or nil,
				anchored = anchored,
				mass = m,
				collidable = collidable,
				canRotate = true,
				rotationCache = {},
				center = isCustom and CalculateCenter(vertices) or frame.AbsolutePosition + frame.AbsoluteSize/2,
				engine = engine,
				spawnedAt = os.clock(),
				lifeSpan = nil,
				anchorRotation = (anchored and not isCustom) and frame.Rotation or nil,
				anchorPos = (anchored and not isCustom) and frame.AbsolutePosition + frame.AbsoluteSize/2 or nil,
				Touched = nil,
				TouchEnded = nil,
				CanvasEdgeTouched = nil,
				Collisions = {
					Body = false,
					CanvasEdge = false,
					Other = {}
				},
				States = {},
				filtered = {},
			}, RigidBody)

			-- Apply offsets if ScreenGui's IgnoreGuiInset property is set to true
			-- Offset = Vector2.new(0, 36)
			if engine.path and engine.path.IgnoreGuiInset then
				self.anchorPos = self.anchorPos and self.anchorPos + Globals.offset or nil
				if not self.custom then
					self.center += Globals.offset
				end
			end

			if #self.rotationCache < 1 then
				CreateRotationCache(self.rotationCache, self.center, self.vertices)
			end
			-- Create events
			self.Touched = Signal.new()
			self.TouchEnded = Signal.new()
			self.CanvasEdgeTouched = Signal.new()

			-- Set parents of points and constraints
			for _, edge in ipairs(edges) do
				edge.Parent = self
				edge._janitor:Add(edge.Parent, "Destroy")
				self._janitor:Add(edge, "Destroy")
			end

			self._janitor:Add(self.Touched, "Destroy")
			self._janitor:Add(self.TouchEnded, "Destroy")
			self._janitor:Add(self.CanvasEdgeTouched, "Destroy")

			if not self.custom then
				self._janitor:Add(self.frame, "Destroy")
				self._janitor:LinkToInstance(self.frame)
			end

			return self
		end

		-- This method projects the RigidBody on an axis. Used for collision detection.
		function RigidBody:CreateProjection(Axis: Vector2, Min: number, Max: number) : (number, number)
			local DotP = Axis:Dot(self.vertices[1].pos)
			Min, Max = DotP, DotP

			for _, v in ipairs(self.vertices) do
				DotP = Axis:Dot(v.pos)
				Min = math.min(DotP, Min)
				Max = math.max(DotP, Max)
			end

			return Min, Max
		end

		-- This method detects collision between two RigidBodies.
		function RigidBody:DetectCollision(other)
			if not self.custom and (not self.frame and not other.frame) then
				return { false, {} }
			end

			-- Calculate center of the Body
			self.center = CalculateCenter(self.vertices)

			-- Initialize collision information
			local minDist = math.huge
			local collision: Types.Collision = {
				axis = nil,
				depth = nil,
				edge = nil,
				vertex = nil
			}

			-- Loop throught both bodies' edges (excluding support edges)
			-- Calculate an axis and then project both bodies to the axis
			-- Assign axis and edge of collision to the collision information dictionary
			-- Calculate the penetration/depth of the collision
			-- Find the vertex that collided with the edge
			-- If a collision took place, return the collision information
			for i = 1, #self.edges + #other.edges, 1 do
				local edge = i <= #self.edges and self.edges[i] or other.edges[i - #self.edges]

				if not edge.support then
					local axis = Vector2.new(
						edge.point1.pos.Y - edge.point2.pos.Y,
						edge.point2.pos.X - edge.point1.pos.X
					).Unit

					local MinA, MinB, MaxA, MaxB
					MinA, MaxA = self:CreateProjection(axis, MinA, MaxA)
					MinB, MaxB = other:CreateProjection(axis, MinB, MaxB)

					local dist = CalculatePenetration(MinA, MaxA, MinB, MaxB)

					if dist > 0 then
						return { false, {} }
					elseif math.abs(dist) < minDist then
						minDist = math.abs(dist)
						collision.axis = axis
						collision.edge = edge
					end
				end
			end

			collision.depth = minDist

			if collision.edge and collision.edge.Parent ~= other then
				local Temp = other
				other = self
				self = Temp
			end

			local centerDif = self.center - other.center
			local dot = collision.axis:Dot(centerDif)

			if dot < 0 then
				collision.axis *= -1
			end

			local minMag = math.huge

			for i = 1, #self.vertices, 1 do
				local dif =  self.vertices[i].pos - other.center
				local dist = collision.axis:Dot(dif)

				if dist < minMag then
					minMag = dist
					collision.vertex = self.vertices[i]
				end
			end

			return { true, collision }
		end

		-- This method is used to apply an external force on the rigid body.
		function RigidBody:ApplyForce(force: Vector2, t: number)
			throwTypeError("force", force, 1, "Vector2")

			if t then
				throwTypeError("time", t, 2, "number")
				if t <= 0 then
					throwException("error", "INVALID_TIME")
				end
			end

			for _, v in ipairs(self.vertices) do
				v:ApplyForce(force, t)
			end
		end

		-- This method updates the positions of the RigidBody's points and constraints.
		function RigidBody:Update(dt: number)
			self.center = CalculateCenter(self.vertices)

			for i, vertex in ipairs(self.vertices) do
				if not self.canRotate then
					local info = self.rotationCache[i]
					local r = info[1]
					local t = info[2]

					vertex:ApplyForce((self.center + Vector2.new(math.cos(t), math.sin(t)) * r) - vertex.pos)
				end

				vertex:Update(dt)
				vertex:Render()
			end

			for _, edge in ipairs(self.edges) do
				for i = 1, self.engine.iterations.constraint do
					edge:Constrain()
				end
				edge:Render()
			end
		end

		-- This method updates the positions and appearance of the RigidBody on screen.
		function RigidBody:Render()
			-- If the RigidBody exceeds its life span, it is destroyed.
			if self.lifeSpan and os.clock() - self.spawnedAt >= self.lifeSpan then
				self:Destroy()
			end

			if self.custom then return end

			-- Apply rotations and update positions
			-- Respects the anchor point of the GuiObject

			if self.anchored then
				local anchorPos = self.anchorPos - CalculateOffset(self.anchorPos, self.frame.AnchorPoint, self.frame.AbsoluteSize)
				self.frame.Position = UDim2.fromOffset(anchorPos.X, anchorPos.Y)
				if self.canRotate then
					self:Rotate(self.anchorRotation)
				end
			else
				local center = self.center - CalculateOffset(self.center, self.frame.AnchorPoint, self.frame.AbsoluteSize)
				local dif: Vector2 = self.vertices[2].pos - self.vertices[1].pos

				self.frame.Position = UDim2.new(0, center.X, 0, center.Y)
				if self.canRotate then
					self.frame.Rotation = math.deg(math.atan2(dif.Y, dif.X))
				end
			end
		end

		-- This method is used to clone the RigidBody while keeping the original one intact.
		function RigidBody:Clone(deepCopy: boolean)
			if not self.custom and not self.frame then return end
			if not self.engine then return end

			local frame
			if not self.custom then
				frame = self.frame:Clone()
				frame.Parent = self.frame.Parent
			end

			local copy = self.engine:Create("RigidBody", {
				Mass = self.mass,
				Object = frame,
				Structure = self.custom and self.structure or nil,
				Anchored = self.anchored,
				Collidable = self.collidable
			})

			-- Copy lifespan, states and filtered RigidBodies
			if deepCopy == true then
				copy.States = self.States

				if self.lifeSpan then
					copy:SetLifeSpan(self.lifeSpan)
				end

				for _, body in ipairs(self.filtered) do
					copy:FilterCollisionsWith(body)
				end
			end

			return copy
		end

		-- This method is used to destroy the RigidBody.
		-- The body's UI element is destroyed, its connections are disconnected and the body is removed from the engine.
		function RigidBody:Destroy(keepFrame: boolean)
			self._janitor:Cleanup()

			for i, body in ipairs(self.engine.bodies) do
				if self.id == body.id then
					table.clear(self.Collisions.Other)
					table.remove(self.engine.bodies, i)
					self.engine.ObjectRemoved:Fire(self)
					break
				end
			end

			table.clear(self.vertices)
			table.clear(self.edges)
		end

		-- This method is used to rotate the RigidBody's UI element.
		-- After rotation the positions of its points and constraints are automatically updated.
		function RigidBody:Rotate(newRotation: number)
			throwTypeError("newRotation", newRotation, 1, "number")

			-- Update anchorRotation if the body is anchored
			if self.anchored and self.anchorRotation then
				self.anchorRotation = newRotation
			end

			-- Apply rotation and update positions
			-- Update the RigidBody's points
			local oldRotation

			if self.custom then
				-- Will need to cache oldRotation somewhere.
				-- This method will result in weird oldRotations for some custom rigid bodies.
				local dif = self.vertices[2].pos - self.vertices[1].pos
				oldRotation = math.deg(math.atan2(dif.Y, dif.X))

				local tempRotationCache = {}
				CreateRotationCache(tempRotationCache, self.center, self.vertices)

				for i, info in ipairs(tempRotationCache) do
					local r = info[1]
					local t = info[2] + math.rad(newRotation)
					local v = self.vertices[i]

					v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
					v.oldPos = v.pos
				end
			else
				oldRotation = self.frame.Rotation

				local offset = CalculateOffset(self.anchorPos, self.frame.AnchorPoint, self.frame.AbsoluteSize)
				local position = self.anchorPos - offset
				self.frame.Position = self.anchored and UDim2.fromOffset(position.X, position.Y) or UDim2.fromOffset(self.center.x, self.center.y)
				self.frame.Rotation = newRotation
				UpdateVertices(self.frame, self.vertices, self.engine)
			end

			return oldRotation, newRotation
		end

		-- This method is used to set a new position of the RigidBody's UI element.
		function RigidBody:SetPosition(PositionX: number, PositionY: number)
			--restrict(self.custom)
			throwTypeError("PositionX", PositionX, 1, "number")
			throwTypeError("PositionY", PositionY, 2, "number")

			-- Update anchorPos if the body is anchored
			if self.anchored and self.anchorPos then
				self.anchorPos = Vector2.new(PositionX, PositionY)
			end

			local oldPosition

			-- Update position
			-- Update the RigidBody's points
			if self.custom then
				oldPosition = UDim2.fromOffset(self.center.X, self.center.Y)
				local tempRotationCache = {}
				CreateRotationCache(tempRotationCache, self.center, self.vertices)

				self.center = Vector2.new(PositionX, PositionY)

				for i, info in ipairs(tempRotationCache) do
					local r = info[1]
					local t = info[2]
					local v = self.vertices[i]

					v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
					v.oldPos = v.pos
				end
			else
				oldPosition = self.frame.Position
				self.frame.Position = UDim2.fromOffset(PositionX, PositionY)
				UpdateVertices(self.frame, self.vertices, self.engine)
			end

			return oldPosition, UDim2.fromOffset(PositionX, PositionY)
		end

		-- This method is used to set a new size of the RigidBody's UI element.
		function RigidBody:SetSize(SizeX: number, SizeY: number)
			restrict(self.custom)
			throwTypeError("SizeX", SizeX, 1, "number")
			throwTypeError("SizeY", SizeY, 2, "number")

			-- Update size
			-- Update the RigidBody's points
			local oldSize = self.frame.Size
			self.frame.Size = UDim2.fromOffset(SizeX, SizeY)
			UpdateVertices(self.frame, self.vertices, self.engine)

			for _, edge in ipairs(self.edges) do
				edge.restLength = (edge.point2.pos - edge.point1.pos).Magnitude
			end

			return oldSize, UDim2.fromOffset(SizeX, SizeY)
		end

		function RigidBody:SetScale(scale: number)
			if not self.custom then return end
			throwTypeError("scale", scale, 1, "number")
			scale = math.max(0.00001, scale)

			for i, info in ipairs(self.rotationCache) do
				local r = info[1] * scale
				local t = info[2]
				local v = self.vertices[i]

				v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
				v.oldPos = v.pos
			end

			for _, edge in ipairs(self.edges) do
				edge.restLength = (edge.point2.pos - edge.point1.pos).Magnitude
			end
		end

		-- This method is used to anchor the RigidBody.
		-- Its position will no longer change.
		function RigidBody:Anchor()
			self.anchored = true
			self.anchorRotation = self.frame and self.frame.Rotation or nil
			self.anchorPos = self.center

			for _, vertex in ipairs(self.vertices) do
				if not vertex.selectable then vertex.snap = self.anchored end
			end
		end

		-- This method is used to unachor and anchored RigidBody.
		function RigidBody:Unanchor()
			self.anchored = false
			self.anchorRotation = nil
			self.anchorPos = nil

			for _, vertex in ipairs(self.vertices) do
				if not vertex.selectable then vertex.snap = self.anchored end
			end
		end

		-- This method is used to determine whether the RigidBody will collide with other RigidBodies.
		function RigidBody:CanCollide(collidable: boolean)
			throwTypeError("collidable", collidable, 1, "boolean")
			self.collidable = collidable
		end

		function RigidBody:CanRotate(canRotate: boolean)
			restrict(self.custom)
			throwTypeError("canRotate", canRotate, 1, "boolean")
			self.canRotate = canRotate

			CreateRotationCache(self.rotationCache, self.center, self.vertices)
		end

		-- The RigidBody's UI Element can be fetched using this method.
		function RigidBody:GetFrame() : GuiObject
			return self.frame
		end

		-- The RigidBody's unique ID can be fetched using this method.
		function RigidBody:GetId() : string
			return self.id
		end

		-- The RigidBody's Points can be fetched using this method.
		function RigidBody:GetVertices()
			return self.vertices
		end

		-- The RigidBody's Constraints can be fetched using this method.
		function RigidBody:GetConstraints()
			return self.edges
		end

		--vThis method is used to set the RigidBody's life span.
		-- Life span is determined by 'seconds'.
		-- After this time in seconds has been passed after the RigidBody is created, the RigidBody is automatically destroyed and removed from the engine.
		function RigidBody:SetLifeSpan(seconds: number)
			throwTypeError("seconds", seconds, 1, "number")
			self.lifeSpan = seconds
		end

		-- This method determines if the RigidBody stays inside the engine's canvas at all times.
		function RigidBody:KeepInCanvas(keepInCanvas: boolean)
			throwTypeError("keepInCanvas", keepInCanvas, 1, "boolean")

			for _, p in ipairs(self.vertices) do
				p.keepInCanvas = keepInCanvas
			end
		end

		-- This method sets a custom frictional damp value just for the RigidBody.
		function RigidBody:SetFriction(friction: number)
			throwTypeError("friction", friction, 1, "number")

			for _, p in ipairs(self.vertices) do
				p.friction =  math.clamp(1 - friction, 0, 1)
			end
		end

		-- This method sets a custom air frictional damp value just for the RigidBody.
		function RigidBody:SetAirFriction(friction: number)
			throwTypeError("friction", friction, 1, "number")

			for _, p in ipairs(self.vertices) do
				p.airfriction =  math.clamp(1 - friction, 0, 1)
			end
		end

		-- This method sets a custom gravitational force just for the RigidBody.
		function RigidBody:SetGravity(force: Vector2)
			throwTypeError("force", force, 1, "Vector2")

			for _, p in ipairs(self.vertices) do
				p.gravity = force
			end
		end

		-- Sets a new mass for the RigidBody
		function RigidBody:SetMass(mass: number)
			if self.mass ~= mass and mass >= 1 then
				self.mass = mass
			end
		end

		-- Returns true if the RigidBody lies within the boundaries of the canvas, else false.
		function RigidBody:IsInBounds() : boolean
			local canvas = self.engine.canvas
			if not canvas then return false end

			-- Check if all vertices lie within the canvas.
			for _, v in ipairs(self.vertices) do
				local pos = v.pos

				if not ((pos.X >= canvas.topLeft.X and pos.X <= canvas.topLeft.X + canvas.size.X) and (pos.Y >= canvas.topLeft.Y and pos.Y <= canvas.topLeft.Y + canvas.size.Y)) then
					return false
				end
			end

			return true
		end

		-- Returns the average of all the velocities of the RigidBody's points
		function RigidBody:AverageVelocity() : Vector2
			local sum = Vector2.new(0, 0)

			for _, v in ipairs(self.vertices) do
				sum += v:Velocity()
			end

			-- Return average
			return sum/#self.vertices
		end

		-- STATE MANAGEMENT
		-- Used to initialize or update states of a RigidBody
		function RigidBody:SetState(state: string, value: any)
			throwTypeError("state", state, 1, "string")
			if self.States[state] == value then return end

			self.States[state] = value
		end

		-- Used to fetch an already existing state
		function RigidBody:GetState(state: string) : any
			throwTypeError("state", state, 1, "string")
			return self.States[state]
		end

		-- Used to fetch the center position of the RigidBody
		function RigidBody:GetCenter()
			return self.center
		end

		-- Used to ignore/filter any collisions with the other RigidBody.
		function RigidBody:FilterCollisionsWith(otherBody)
			if not otherBody.id or not typeof(otherBody.id) == "string" or not otherBody.filtered then
				throwException("error", "INVALID_RIGIDBODY")
			end

			if otherBody.id == self.id then throwException("error", "SAME_ID") end

			-- Insert the ids into their respective places
			if not table.find(self.filtered, otherBody.id) then
				table.insert(self.filtered, otherBody.id)
				table.insert(otherBody.filtered, self.id)
			end
		end

		-- Used to unfilter collisions with the other RigidBody.
		-- The two bodies will now collide with each other.
		function RigidBody:UnfilterCollisionsWith(otherBody)
			if not otherBody.id or not typeof(otherBody.id) == "string" or not otherBody.filtered then
				throwException("error", "INVALID_RIGIDBODY")
			end

			if otherBody.id == self.id then throwException("error", "SAME_ID") end

			local i1 = table.find(self.filtered, otherBody.id)
			local i2 = table.find(otherBody.filtered, self.id)

			-- Remove the ids from their respective places
			if i1 and i2 then
				table.remove(self.filtered, i1)
				table.remove(otherBody.filtered, i2)
			end
		end

		-- Returns all filtered RigidBodies.
		function RigidBody:GetFilteredRigidBodies()
			return self.filtered
		end

		-- Returns an array of all RigidBodies that are in collision with the current
		function RigidBody:GetTouchingRigidBodies()
			return self.Collisions.Other
		end

		-- Determines the max force that can be aoplied to the RigidBody.
		function RigidBody:SetMaxForce(maxForce: number)
			throwTypeError("maxForce", maxForce, 1, "number")
			for _, p in ipairs(self.vertices) do
				p:SetMaxForce(maxForce)
			end
		end

		return RigidBody
	end
	fake_module_scripts[script] = module_script
end



local fake_module_scripts = {}

do 
	local script = Instance.new('ModuleScript', game.ReplicatedStorage.Nature2D)
	script.Name = "Engine"
	local function module_script()
		-- The Engine or the core of the library handles all the RigidBodies, constraints and points.
		-- It's responsible for the simulation of these elements and handling all tasks related to the library.

		-- Services and utilities
		local RigidBody = require(game.ReplicatedStorage.Nature2D.Physics.RigidBody)
		local Point = require(script.Parent.Physics.Point)
		local Constraint = require(script.Parent.Physics.Constraint)
		local Globals = require(game.ReplicatedStorage.Nature2D.Constants.Globals)
		local Signal = require(game.ReplicatedStorage.Nature2D.Utilities.Signal)
		local Quadtree = require(game.ReplicatedStorage.Nature2D.Utilities.Quadtree)
		local Janitor = require(game.ReplicatedStorage.Nature2D.Utilities.Janitor)
		local Types = require(game.ReplicatedStorage.Nature2D.Types)
		local throwException = require(game.ReplicatedStorage.Nature2D.Debugging.Exceptions)
		local throwTypeError = require(game.ReplicatedStorage.Nature2D.Debugging.TypeErrors)
		local RunService = game:GetService("RunService")

		local Engine = {}
		Engine.__index = Engine

		-- [PRIVATE]
		-- Search and return an element from a table using a lambda function
		local function SearchTable(t: { any }, a: any,  lambda: (a: any, b: any) -> boolean) : any
			for _, v in ipairs(t) do
				if lambda(a, v) then
					return v
				end
			end

			return nil
		end

		-- This method is responsible for separating two rigidbodies if they collide with each other.
		local function CollisionResponse(body: Types.RigidBody, other: Types.RigidBody, isColliding: boolean, Collision: Types.Collision, dt: number, oldCollidingWith, iteration: number)
			if not isColliding then return end

			-- Fire the touched event
			if iteration == 1 and body.Touched._handlerListHead and body.Touched._handlerListHead.Connected then
				if not SearchTable(oldCollidingWith, other, function(a, b) return a.id == b.id end) then
					body.Touched:Fire(other.id, Collision)
				end
			end

			-- Calculate penetration in 2 dimensions
			local penetration: Vector2 = Collision.axis * Collision.depth
			local p1: Types.Point = Collision.edge.point1
			local p2: Types.Point = Collision.edge.point2

			-- Calculate a t alpha value
			local t
			if math.abs(p1.pos.X - p2.pos.X) > math.abs(p1.pos.Y - p2.pos.Y) then
				t = (Collision.vertex.pos.X - penetration.X - p1.pos.X)/(p2.pos.X - p1.pos.X)
			else
				t = (Collision.vertex.pos.Y - penetration.Y - p1.pos.Y)/(p2.pos.Y - p1.pos.Y)
			end

			-- Create a lambda
			local factor: number = 1 / (t^2 + (1 - t)^2)

			-- Calculate masses
			local bodyMass = Collision.edge.Parent.mass
			local m = t * bodyMass + (1 - t) * bodyMass
			local cMass = 1 / (m + Collision.vertex.Parent.Parent.mass)

			-- Calculate ratios of collision effects
			local r1 = Collision.vertex.Parent.Parent.mass * cMass
			local r2 = m * cMass

			-- If the body is not anchored, apply forces to the constraint
			if not Collision.edge.Parent.anchored then
				p1.pos -= penetration * ((1 - t) * factor * r1)
				p2.pos -= penetration * (t * factor * r1)
			end

			-- If the body is not anchored, apply forces to the point
			if not Collision.vertex.Parent.Parent.anchored then
				Collision.vertex.pos += penetration * r2
			end
		end

		-- [PUBLIC]
		-- This method is used to initialize basic configurations of the engine and allocate memory for future tasks.
		function Engine.init(screengui: Instance)
			if not typeof(screengui) == "Instance" or not screengui:IsA("Instance") then
				error("Invalid Argument #1. 'screengui' must be a ScreenGui.", 2)
			end

			local self = setmetatable({
				bodies = {},
				constraints = {},
				points = {},
				connection = nil,
				_janitor = nil,
				gravity = Globals.engineInit.gravity,
				friction = Globals.engineInit.friction,
				airfriction = Globals.engineInit.airfriction,
				bounce = Globals.engineInit.bounce,
				timeSteps = Globals.engineInit.timeSteps,
				mass = Globals.universalMass,
				path = screengui,
				speed = Globals.speed,
				quadtrees = false,
				independent = true,
				canvas = {
					frame = nil,
					topLeft = Globals.engineInit.canvas.topLeft,
					size = Globals.engineInit.canvas.size
				},
				iterations = {
					constraint = 1,
					collision = 1,
				},
				Started = Signal.new(),
				Stopped = Signal.new(),
				ObjectAdded = Signal.new(),
				ObjectRemoved = Signal.new(),
				Updated = Signal.new(),
			}, Engine)

			local janitor = Janitor.new()
			janitor:Add(self.Started, "Destroy")
			janitor:Add(self.Stopped, "Destroy")
			janitor:Add(self.ObjectAdded, "Destroy")
			janitor:Add(self.ObjectRemoved, "Destroy")
			janitor:Add(self.Updated, "Destroy")

			self._janitor = janitor

			return self
		end

		-- This method is used to start simulating rigid bodies and constraints.
		function Engine:Start()
			if not self.canvas then throwException("error", "NO_CANVAS_FOUND") end
			if #self.bodies == 0 then throwException("warn", "NO_RIGIDBODIES_FOUND") end
			if self.connection then throwException("warn", "ALREADY_STARTED") return end

			-- Fire Engine.Started event
			self.Started:Fire()

			-- Create a RenderStepped connection
			local connection;
			connection = RunService.RenderStepped:Connect(function(dt)
				local tree;

				-- Create a quadtree and insert bodies if neccesary
				if self.quadtrees then
					tree = Quadtree.new(self.canvas.topLeft, self.canvas.size, 4)

					for _, body in ipairs(self.bodies) do
						if body.collidable then
							tree:Insert(body)
						end
					end
				else
					if self.iterations.collision ~= 1 then
						self.iterations.collision = 1
					end
				end

				-- Loop through each body
				-- Update the body
				-- Calculate the closest RigidBodies to a given body if neccesary
				for _, body in ipairs(self.bodies) do
					local OldCollidingWith = body.Collisions.Other
					local CollidingWith = {}

					if body.collidable then

						local filtered = self.bodies

						if self.quadtrees then
							local abs = body.custom and body.size or body.frame.AbsoluteSize
							local side = abs.X > abs.Y and abs.X or abs.Y

							local range = {
								position = body.center - Vector2.new(side * 1.5, side * 1.5),
								size = Vector2.new(side * 3, side * 3)
							}

							filtered = tree:Search(range, {})
						end

						-- Loop through the filtered RigidBodies
						-- Detect collisions
						-- Process collision response
						for _, other in ipairs(filtered) do
							if body.id ~= other.id and other.collidable and not table.find(body.filtered, other.id) then
								local result, isColliding, Collision, didCollide

								for i = 1, self.iterations.collision do
									result = body:DetectCollision(other)
									isColliding = result[1]
									Collision = result[2]

									if i == 1 and not isColliding then
										break
									end

									didCollide = true

									CollisionResponse(body, other, isColliding, Collision, dt, OldCollidingWith, i)
								end

								if didCollide then
									body.Collisions.Body = true
									other.Collisions.Body = true
									table.insert(CollidingWith, other)
								else
									body.Collisions.Body = false
									other.Collisions.Body = false

									-- Fire TouchEnded event
									if body.TouchEnded._handlerListHead and body.TouchEnded._handlerListHead.Connected then
										if SearchTable(OldCollidingWith, other, function (a, b) return a.id == b.id end) then
											body.TouchEnded:Fire(other.id)
										end
									end
								end
							end
						end
					end

					body.Collisions.Other = CollidingWith

					-- Render and Update of the body
					body:Update(dt)
					body:Render()
				end

				-- Render all custom constraints
				if #self.constraints > 0 then
					for _, constraint in ipairs(self.constraints) do
						if constraint._TYPE ~= "SPRING" then
							for i = 1, self.iterations.constraint do
								constraint:Constrain()
							end
						else
							constraint:Constrain()
						end

						constraint:Render()
					end
				end

				-- Render all custom points
				if #self.points > 0 then
					for _, point in ipairs(self.points) do
						point:Update(dt)
						point:Render()
					end
				end

				self.Updated:Fire()
			end)

			self.connection = connection
			self._janitor:Add(self.connection, "Disconnect", "MainConnection")
		end

		-- This method is used to stop simulating rigid bodies and constraints.
		function Engine:Stop()
			-- Fire Engine.Stopped event
			-- Disconnect all connections
			if self.connection then
				self.Stopped:Fire()
				self._janitor:Remove("MainConnection")
				self.connection = nil
			end
		end

		-- This method is used to create RigidBodies, Constraints and Points
		function Engine:Create(object: string, properties: Types.Properties)
			-- Validate types of the object and property table
			throwTypeError("object", object, 1, "string")
			throwTypeError("properties", properties, 2, "table")

			-- Validate object
			if object ~= "Constraint" and object ~= "Point" and object ~= "RigidBody" then
				throwException("error", "INVALID_OBJECT")
			end

			-- Validate property table
			for prop, value in pairs(properties) do
				if not table.find(Globals.VALID_OBJECT_PROPS, prop) then
					throwException("error", "INVALID_PROPERTY", string.format("%q is not a valid property!", prop))
					return
				end

				if not table.find(Globals[string.lower(object)].props, prop) then
					throwException("error", "INVALID_PROPERTY", string.format("%q is not a valid property for a %s!", prop, object))
					return
				end

				if Globals.OBJECT_PROPS_TYPES[prop] and typeof(value) ~= Globals.OBJECT_PROPS_TYPES[prop] then
					error(
						string.format(
							"[Nature2D]: Invalid Property type for %q. Expected %q got %q.",
							prop,
							Globals.OBJECT_PROPS_TYPES[prop],
							typeof(value)
						),
						2
					)
				end
			end

			-- Check if must-have properties exist in the property table
			for _, prop in ipairs(Globals[string.lower(object)].must_have) do
				if not properties[prop] then
					local throw = true

					if prop == "Object" and properties.Structure then
						throw = false
					end

					if throw then
						throwException("error", "MUST_HAVE_PROPERTY", string.format("You must specify the %q property for a %s!", prop, object))
						return
					end
				end
			end

			local newObject

			-- Create the Point object
			if object == "Point" then
				local newPoint = Point.new(properties.Position or Vector2.new(), self.canvas, self, {
					snap = properties.Snap,
					selectable = false,
					render = properties.Visible,
					keepInCanvas = properties.KeepInCanvas or true
				}, nil)

				-- Apply properties
				if properties.Radius then newPoint:SetRadius(properties.Radius)	end
				if properties.Color then newPoint:Stroke(properties.Color) end

				table.insert(self.points, newPoint)
				newObject = newPoint
				-- Create the constraint object
			elseif object == "Constraint" then
				if not table.find(Globals.constraint.types, string.lower(properties.Type or "")) then
					throwException("error", "INVALID_CONSTRAINT_TYPE")
				end

				-- Validate restlength and thickness of the constraint
				if properties.RestLength and properties.RestLength <= 0 then
					throwException("error", "INVALID_CONSTRAINT_LENGTH")
				end

				if properties.Thickness and properties.Thickness <= 0 then
					throwException("error", "INVALID_CONSTRAINT_THICKNESS")
				end

				if properties.Point1 and properties.Point2 and properties.Type then
					-- Calculate distance
					local dist = (properties.Point1.pos - properties.Point2.pos).Magnitude

					local newConstraint = Constraint.new(properties.Point1, properties.Point2, self.canvas, {
						restLength = properties.RestLength or dist,
						render = properties.Visible,
						thickness = properties.Thickness,
						support = false,
						TYPE = string.upper(properties.Type)
					}, self)

					-- Apply properties
					if properties.SpringConstant then newConstraint:SetSpringConstant(properties.SpringConstant) end
					if properties.Color then newConstraint:Stroke(properties.Color) end

					table.insert(self.constraints, newConstraint)
					newObject = newConstraint
				end
				-- Create the RigidBody object
			elseif object == "RigidBody" then
				-- Validate custom RigidBody structure

				if properties.Object and not properties.Object:IsA("GuiObject") and not properties.Structure then
					error("'Object' must be a GuiObject", 2)
				end

				local obj = nil
				if not properties.Structure then
					obj = properties.Object
				end

				local custom: Types.Custom = {
					Vertices = {},
					Edges = {}
				}

				if properties.Structure then
					if not self.canvas.frame then
						throwException("error", "CANVAS_FRAME_NOT_FOUND")
					end

					for _, c in ipairs(properties.Structure) do
						local a = c[1]
						local b = c[2]
						local support = c[3]

						if typeof(a) ~= "Vector2" or typeof(b) ~= "Vector2" then
							error("[Nature2D]: Invalid point positions for custom RigidBody structure.", 2)
						end

						if support and typeof(support) ~= "boolean" then error("[Nature2D]: 'support' must be a boolean or nil") end
						if a == b then error("[Nature2D]: A constraint cannot have the same points.", 2) end

						local PointA = SearchTable(custom.Vertices, a, function(i, v) return i == v.pos end)
						local PointB = SearchTable(custom.Vertices, b, function(i, v) return i == v.pos end)

						if not PointA then
							PointA = Point.new(a, self.canvas, self, {
								snap = properties.Anchored,
								selectable = false,
								render = false,
								keepInCanvas = properties.KeepInCanvas or true
							})
							table.insert(custom.Vertices, PointA)
						end

						if not PointB then
							PointB = Point.new(b, self.canvas, self, {
								snap = properties.Anchored,
								selectable = false,
								render = false,
								keepInCanvas = properties.KeepInCanvas or true
							})
							table.insert(custom.Vertices, PointB)
						end

						local edge = Constraint.new(PointA, PointB, self.canvas, {
							render = support or false or true,
							thickness = 2,
							support = support,
							TYPE = "ROD"
						}, self)

						table.insert(custom.Edges, edge)
					end
				end

				local newBody = RigidBody.new(
					obj,
					properties.Mass or self.mass,
					properties.Collidable,
					properties.Anchored,
					self,
					properties.Structure and custom or nil,
					properties.Structure
				)

				--Apply properties
				if properties.LifeSpan then newBody:SetLifeSpan(properties.LifeSpan) end
				if typeof(properties.KeepInCanvas) == "boolean" then newBody:KeepInCanvas(properties.KeepInCanvas) end
				if properties.Gravity then newBody:SetGravity(properties.Gravity) end
				if properties.Friction then newBody:SetFriction(properties.Friction) end
				if properties.AirFriction then newBody:SetAirFriction(properties.AirFriction) end
				if typeof(properties.CanRotate) == "boolean" and not properties.Structure then newBody:CanRotate(properties.CanRotate) end

				table.insert(self.bodies, newBody)
				newObject = newBody
			end

			self._janitor:Add(newObject, "Destroy")

			self.ObjectAdded:Fire(newObject)
			return newObject
		end

		-- This method is used to fetch all RigidBodies that have been created.
		-- Ones that have been destroyed, won't be fetched.
		function Engine:GetBodies()
			return self.bodies
		end

		-- This method is used to fetch all Constraints that have been created.
		-- Ones that have been destroyed, won't be fetched.
		function Engine:GetConstraints()
			return self.constraints
		end

		-- This method is used to fetch all Points that have been created.
		function Engine:GetPoints()
			return self.points
		end

		-- This function is used to initialize boundaries to which all bodies and constraints obey.
		-- An object cannot go past this boundary.
		function Engine:CreateCanvas(topLeft: Vector2, size: Vector2, frame: Frame)
			throwTypeError("topLeft", topLeft, 1, "Vector2")
			throwTypeError("size", size, 2, "Vector2")

			self.canvas.topLeft = topLeft
			self.canvas.size = size

			if frame and frame:IsA("Frame") then
				self.canvas.frame = frame
			end
		end

		-- This method is used to determine the simulation speed of the engine.
		-- By default the simulation speed is set to 55.
		function Engine:SetSimulationSpeed(speed: number)
			throwTypeError("speed", speed, 1, "number")
			self.speed = speed
		end

		-- This method is used to configure universal physical properties possessed by all rigid bodies and constraints.
		function Engine:SetPhysicalProperty(property: string, value: Vector2 | number)
			throwTypeError("property", property, 1, "string")

			local properties = Globals.properties

			-- Update properties of the Engine
			local function Update(object)
				if string.lower(property) == "collisionmultiplier" then
					throwTypeError("value", value, 2, "number")
					object.bounce = value
				elseif string.lower(property) == "gravity" then
					throwTypeError("value", value, 2, "Vector2")
					object.gravity = value
				elseif string.lower(property) == "friction" then
					throwTypeError("value", value, 2, "number")
					object.friction = math.clamp(1 - value, 0, 1)
				elseif string.lower(property) == "airfriction" then
					throwTypeError("value", value, 2, "number")
					object.airfriction = math.clamp(1 - value, 0, 1)
				elseif string.lower(property) == "universalmass" then
					throwTypeError("value", value, 2, "number")
					object.mass = math.max(0, value)
				end
			end

			-- Validate and update properties
			if table.find(properties, string.lower(property)) then
				if #self.bodies < 1 then
					Update(self)
				else
					Update(self)
					for _, b in ipairs(self.bodies) do
						for _, v in ipairs(b:GetVertices()) do
							Update(v)
						end
					end
				end
			else
				throwException("error", "PROPERTY_NOT_FOUND")
			end
		end

		-- This method is used to fetch an individual rigid body from its ID.
		function Engine:GetBodyById(id: string)
			throwTypeError("id", id, 1, "string")

			for _, b in ipairs(self.bodies) do
				if b.id == id then
					return b
				end
			end

			return
		end

		-- This method is used to fetch an individual constraint body from its ID.
		function Engine:GetConstraintById(id: string)
			throwTypeError("id", id, 1, "string")

			for _, c in ipairs(self.constraints) do
				if c.id == id then
					return c
				end
			end

			return
		end

		function Engine:GetDebugInfo() : Types.DebugInfo
			return {
				Objects = {
					RigidBodies = #self.bodies,
					Constraints = #self.constraints,
					Points = #self.points
				},
				Running = not not (self.connection),
				Physics = {
					Gravity = self.gravity,
					Friction = 1 - self.friction,
					AirFriction = 1 - self.airfriction,
					CollisionMultiplier = self.bounce,
					TimeSteps = self.timeSteps,
					SimulationSpeed = self.speed,
					UsingQuadtrees = self.quadtrees,
					FramerateIndependent = self.independent
				},
				Path = self.path,
				Canvas = {
					Frame = self.canvas.frame,
					TopLeft = self.canvas.topLeft,
					Size = self.canvas.size
				}
			}
		end

		-- Determines if Quadtrees will be used in collision deteWction.
		-- By default this is set to false
		function Engine:UseQuadtrees(use: boolean)
			throwTypeError("useQuadtrees", use, 1, "boolean")
			self.quadtrees = use
		end

		-- Determines if Frame rate does not affect the simulation speed.
		-- By default set to true.
		function Engine:FrameRateIndependent(independent: boolean)
			throwTypeError("independent", independent, 1, "boolean")
			self.independent = independent
		end

		function Engine:SetConstraintIterations(iterations: number)
			throwTypeError("iterations", iterations, 1, "number")
			self.iterations.constraint = math.floor(math.clamp(iterations, 1, 10))
		end

		function Engine:SetCollisionIterations(iterations: number)
			throwTypeError("iterations", iterations, 1, "number")

			if self.quadtrees then
				self.iterations.collision = math.floor(math.clamp(iterations, 1, 10))
			else
				throwException("warn", "CANNOT_SET_COLLISION_ITERATIONS")
			end
		end

		function Engine:Destroy()
			self._janitor:Destroy()
			setmetatable(self, nil)
		end

		return Engine
	end
	fake_module_scripts[script] = module_script
end



